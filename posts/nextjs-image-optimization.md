---
title: "Next.js 이미지 성능 최적화"
date: "2025-09-09"
description: "고해상도 게임 이미지를 효율적으로 로딩하여 페이지 초기 경험(LCP)을 개선한 Next.js 사례를 정리"
---

### 들어가며

GAME DB 프로젝트를 진행하면서 가장 큰 성능 문제는 고해상도 이미지 로딩으로 인한 LCP 지연이었습니다.
이번 글에서는 Next.js 이미지 최적화로 초기 로딩 속도를 개선한 방법을 정리합니다.

### 1. 문제 분석

![LCP 개선 전](/images/posts/nextjs-image-optimization/lcp-before.png)\
Lighthouse 성능 측정 결과, 페이지 진입 후 이미지 로딩 때문에 LCP가 3.5초로 지연되어 초기 사용자 경험에 영향을 주고 있음을 확인했습니다.

### 1-1. 문제 원인

저는 Next.js를 이번 프로젝트에서 처음 사용하면서 기존에는 `<img>` 태그로 원본 JPEG 이미지(평균 3.8MB) 직접 로드를 하고 있었습니다. 그러다보니 Chrome DevTools Network 탭 분석 결과, 이미지 전송에만 7.5MB(20개 데이터 기준) 소요가 되었고, 또한 표시 크기(320x160px) 대비 큰 원본 이미지 다운로드로 대역폭 낭비 확인하였습니다.

### 2. 솔루션

처음부터 성능 검사하면서 작업 한 건 아니라 더 낮을 수도 있었던 성능..
실제 프로젝트에서 Next.js Image 컴포넌트를 적용한 최적화 방법들을 정리해보고자 합니다.

### 2-1. WebP/AVIF 포맷 변환

**문제 상황**
기존에는 `<img>` 태그로 원본 JPEG 이미지(평균 3.8MB)를 직접 로드했습니다. Chrome DevTools Network 탭 분석 결과, 이미지 전송에만 7.5MB(20개 게임 기준)가 소요되었습니다.

**왜 포맷 변환이 필요한가?**

JPEG 파일이 왜 이렇게 큰 걸까요? JPEG는 1990년대에 만들어진 포맷으로, 당시 기술 수준에서 최선이었지만 지금 시점에서는 비효율적입니다.

- **WebP**: Google이 개발한 포맷으로, JPEG 대비 약 25-35% 용량 감소
- **AVIF**: 최신 포맷으로, JPEG 대비 최대 50% 용량 감소 + 더 나은 화질 유지

쉽게 비유하자면, 같은 내용의 책을 옛날 활자체로 인쇄하는 것(JPEG)과 최신 압축 기술로 인쇄하는 것(WebP/AVIF)의 차이입니다. 전달하는 내용(이미지 품질)은 같지만, 용량이 크게 줄어듭니다.

**실제 적용**

Next.js Image 컴포넌트는 기본적으로 WebP 포맷 변환을 지원하지만, 더 나은 압축률을 위해 AVIF까지 활성화하기로 했습니다.

**왜 AVIF를 추가했나?**

- WebP도 충분히 효율적이지만(JPEG 대비 25-35% 감소), AVIF는 WebP보다 20-30% 더 압축됩니다
- 2024년 기준 주요 브라우저(Chrome 85+, Firefox 93+, Safari 16.4+)에서 모두 지원
- 지원하지 않는 브라우저는 자동으로 WebP로 대체되므로 호환성 문제 없음
- 둘 다 미지원 시 (구형 브라우저) → 원본 포맷(JPEG/PNG) 제공

```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    formats: ["image/avif", "image/webp"], // AVIF 우선, WebP는 대체(fallback)
  },
};

export default nextConfig;
```

### 2-2. sizes 속성

기존 페이지에서는 게임 카드 이미지를 표시할 때, 실제 표시 크기인 320x160px에 비해 원본 이미지가 4161x2219px로 매우 큰 상태였습니다. 이로 인해 브라우저가 모든 픽셀 데이터를 다운로드해야 했고, 그 결과 초기 페이지 렌더링이 지연되어 LCP가 3.5초에 달하며 사용자의 초기 경험을 저해하고 있었습니다.

문제를 분석해보니, 원본 이미지가 표시 크기에 비해 지나치게 크기 때문에 브라우저가 필요 이상의 데이터를 처리해야 했고, 그로 인해 페이지 진입 시 사용자가 체감하는 속도가 느려지고 초기 화면 진입 경험이 떨어지는 것이 확인되었습니다.

```tsx
<Image
  src="/example.jpg"
  alt="게임 이미지"
  width={320}
  height={160}
  sizes="320px"
/>
```

이를 해결하기 위해 Next.js `<Image>` 컴포넌트의 sizes 속성을 활용했습니다. `sizes="320px"`를 지정함으로써 브라우저가 이미지의 실제 표시 크기에 맞는 파일만 다운로드하도록 유도했습니다. 그 결과, 불필요한 고해상도 이미지 다운로드를 방지하고, LCP 지연을 최소화할 수 있었습니다.

### 2-3. priority와 lazy loading

게임 목록 페이지에서는 여러 줄로 카드가 나열되기 때문에, 모든 썸네일 이미지를 한꺼번에 priority로 불러오면 브라우저 리소스를 과도하게 사용하게 되어 정작 가장 중요한 LCP 이미지를 불러오는 속도가 늦어지는 문제가 발생했습니다.

이를 해결하기 위해, 초기 화면에 표시되는 첫 2행 정도의 이미지(약 10개)만 priority=true로 설정하고, 나머지 이미지는 스크롤 시 로드되는 lazy loading으로 처리했습니다. 이렇게 하면 사용자가 페이지에 처음 진입했을 때 실제로 보이는 영역만 먼저 로딩되고, 화면 밖의 이미지들은 필요할 때 불러오기 때문에 브라우저 리소스를 효율적으로 사용할 수 있습니다.

```tsx
// 첫 10개 이미지만 priority=true
const priority = index < 10;

<Image
  src={game.background_image}
  alt={game.name}
  width={320}
  height={160}
  priority={priority} // 10개까지만 true, 나머지는 자동 lazy loading
/>;
```

### 2-4. quality 설정

이미지 성능 최적화를 위해 quality 속성을 활용했습니다. 메인 이미지는 quality={75}로 설정하여 시각적 품질을 높였고, 화면에서 작은 썸네일 이미지는 quality={50}로 낮춰 용량을 줄였습니다.

이 접근의 이유는 간단합니다. 메인 이미지는 사용자의 시각적 만족도와 몰입감을 위해 고품질을 유지하는 것이 중요하지만, 썸네일처럼 화면에서 작게 보여지는 이미지들은 굳이 고해상도를 유지할 필요가 없습니다. 낮은 품질로도 시각적인 차이가 거의 없기 때문에 파일 용량을 줄일 수 있고, 그만큼 페이지 로딩 속도를 개선할 수 있습니다.

이렇게 메인과 서브 이미지의 품질을 적절히 조절함으로써 시각적 만족도를 유지하면서도 전체 페이지의 렌더링 성능을 향상시킬 수 있었습니다.

```tsx
/* 메인 이미지 - 고품질 */
<Image src={mainImage} alt={gameName} quality={75} />;

/* 썸네일 - 저품질 */
<Image src={thumbnail} alt={`${gameName} screenshot`} quality={50} />;
```

### 3. 결과

![LCP 개선 후](/images/posts/nextjs-image-optimization/lcp-after.png)
이미지 최적화 하고나서, 성능 지표에서 변화를 확인할 수 있었습니다.
중요한 사용자 체감 지표인 LCP가 기존 3.5초에서 0.6초로 개선되었고, Lighthouse 성능 점수 또한 81점에서 100점으로 향상되었습니다.

### 마치며

이번 프로젝트에서는 Next.js Image 컴포넌트를 활용해 고해상도 게임 이미지로 인한 LCP 지연 문제를 단계적으로 해결했습니다. 최신 이미지 포맷(WebP/AVIF) 적용, sizes 속성으로 실제 표시 크기 반영, priority와 lazy loading의 적절한 조합, 그리고 quality 설정을 통한 시각적 품질과 용량 균형 조절까지, 각 방법이 서로 보완하면서 초기 로딩 성능을 크게 개선할 수 있었습니다.

작은 최적화 하나가 사용자 경험에 미치는 영향이 생각보다 크다는 것을 다시 한번 느꼈습니다. 특히 이미지와 같이 용량이 큰 리소스는 단순히 로딩 속도만이 아니라, 브라우저 렌더링, 네트워크 사용량, 체감 속도까지 고려해야 한다는 점이 중요하다는 것을 깨닫는 경험이었습니다.
